/*
 * generated by Xtext 2.9.2
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myBash.ArithmeticCommand;
import org.xtext.example.mydsl.myBash.ArithmeticExpansion;
import org.xtext.example.mydsl.myBash.ArithmeticForStatement;
import org.xtext.example.mydsl.myBash.Array;
import org.xtext.example.mydsl.myBash.Assignment;
import org.xtext.example.mydsl.myBash.Bash;
import org.xtext.example.mydsl.myBash.BinaryExpression;
import org.xtext.example.mydsl.myBash.CasePattern;
import org.xtext.example.mydsl.myBash.CaseStatement;
import org.xtext.example.mydsl.myBash.CommandName;
import org.xtext.example.mydsl.myBash.CommandSubstitution;
import org.xtext.example.mydsl.myBash.CompoundList;
import org.xtext.example.mydsl.myBash.CondBinaryExpression;
import org.xtext.example.mydsl.myBash.CondCommand;
import org.xtext.example.mydsl.myBash.CondConst;
import org.xtext.example.mydsl.myBash.CondUnaryExpression;
import org.xtext.example.mydsl.myBash.ConditionalOperator;
import org.xtext.example.mydsl.myBash.ConstPrimaryItem;
import org.xtext.example.mydsl.myBash.DQString;
import org.xtext.example.mydsl.myBash.ElseIfBlock;
import org.xtext.example.mydsl.myBash.ForStatement;
import org.xtext.example.mydsl.myBash.FunctionDefine;
import org.xtext.example.mydsl.myBash.GroupCommand;
import org.xtext.example.mydsl.myBash.IfStatement;
import org.xtext.example.mydsl.myBash.IndexEvaluation;
import org.xtext.example.mydsl.myBash.LAssignment;
import org.xtext.example.mydsl.myBash.Literal;
import org.xtext.example.mydsl.myBash.MyBashPackage;
import org.xtext.example.mydsl.myBash.ParameterExpansion;
import org.xtext.example.mydsl.myBash.Pattern;
import org.xtext.example.mydsl.myBash.Pipeline;
import org.xtext.example.mydsl.myBash.PipelineCommand;
import org.xtext.example.mydsl.myBash.PrefixExpression;
import org.xtext.example.mydsl.myBash.PrimaryItem;
import org.xtext.example.mydsl.myBash.ProcessSubstitution;
import org.xtext.example.mydsl.myBash.Redirection;
import org.xtext.example.mydsl.myBash.RegularConst;
import org.xtext.example.mydsl.myBash.RegularExpression;
import org.xtext.example.mydsl.myBash.ReplaceProcessor;
import org.xtext.example.mydsl.myBash.SimpleCommand;
import org.xtext.example.mydsl.myBash.SimpleList;
import org.xtext.example.mydsl.myBash.SingleProcessor;
import org.xtext.example.mydsl.myBash.SubStringProcessor;
import org.xtext.example.mydsl.myBash.Subshell;
import org.xtext.example.mydsl.myBash.SuffixExpression;
import org.xtext.example.mydsl.myBash.VariableId;
import org.xtext.example.mydsl.myBash.WhileStatement;
import org.xtext.example.mydsl.myBash.Word;
import org.xtext.example.mydsl.services.MyBashGrammarAccess;

@SuppressWarnings("all")
public class MyBashSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyBashGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyBashPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyBashPackage.ARITHMETIC_COMMAND:
				if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getArithmeticCommandRule()) {
					sequence_ArithmeticCommand(context, (ArithmeticCommand) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_ArithmeticCommand_Command(context, (ArithmeticCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_ArithmeticCommand_Command_SimpleList(context, (ArithmeticCommand) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.ARITHMETIC_EXPANSION:
				sequence_ArithmeticExpansionStart(context, (ArithmeticExpansion) semanticObject); 
				return; 
			case MyBashPackage.ARITHMETIC_FOR_STATEMENT:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_ForStatement(context, (ArithmeticForStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_ForStatement_SimpleList(context, (ArithmeticForStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getForStatementRule()) {
					sequence_ForStatement(context, (ArithmeticForStatement) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.ARRAY:
				sequence_ArrayStart(context, (Array) semanticObject); 
				return; 
			case MyBashPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MyBashPackage.BASH:
				sequence_Bash(context, (Bash) semanticObject); 
				return; 
			case MyBashPackage.BINARY_EXPRESSION:
				sequence_AdditionSubtraction_Arithmetic_BitwiseAND_BitwiseExclusiveOR_BitwiseOR_BitwiseShifts_Comparison_EqualityAndInequality_Evaluation_Exponentiation_LogicAnd_LogicOr_MultiplicationDivisionRemainder(context, (BinaryExpression) semanticObject); 
				return; 
			case MyBashPackage.CASE_PATTERN:
				if (rule == grammarAccess.getCasePatternContinueRule()) {
					sequence_CasePatternContinue(context, (CasePattern) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCasePatternRule()) {
					sequence_CasePattern(context, (CasePattern) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.CASE_STATEMENT:
				if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getCaseStatementRule()) {
					sequence_CaseStatement(context, (CaseStatement) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_CaseStatement_Command(context, (CaseStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_CaseStatement_Command_SimpleList(context, (CaseStatement) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.COMMAND_NAME:
				sequence_CommandName(context, (CommandName) semanticObject); 
				return; 
			case MyBashPackage.COMMAND_SUBSTITUTION:
				if (rule == grammarAccess.getCommandSubstitutionStartRule()) {
					sequence_CommandSubstitutionStart(context, (CommandSubstitution) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpansionRule()
						|| rule == grammarAccess.getWordElementRule()
						|| rule == grammarAccess.getStringElementRule()
						|| rule == grammarAccess.getCommandSubstitutionRule()) {
					sequence_CommandSubstitution_CommandSubstitutionStart(context, (CommandSubstitution) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.COMPOUND_LIST:
				sequence_CompoundList(context, (CompoundList) semanticObject); 
				return; 
			case MyBashPackage.COND_BINARY_EXPRESSION:
				sequence_CondExp(context, (CondBinaryExpression) semanticObject); 
				return; 
			case MyBashPackage.COND_COMMAND:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_CondCommand(context, (CondCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_CondCommand_SimpleList(context, (CondCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getCondCommandRule()) {
					sequence_CondCommand(context, (CondCommand) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.COND_CONST:
				sequence_CondConst(context, (CondConst) semanticObject); 
				return; 
			case MyBashPackage.COND_UNARY_EXPRESSION:
				sequence_CondExp_CondOrAnd(context, (CondUnaryExpression) semanticObject); 
				return; 
			case MyBashPackage.CONDITIONAL_OPERATOR:
				sequence_ConditionalOperator(context, (ConditionalOperator) semanticObject); 
				return; 
			case MyBashPackage.CONST_PRIMARY_ITEM:
				sequence_PrimaryItem(context, (ConstPrimaryItem) semanticObject); 
				return; 
			case MyBashPackage.DQ_STRING:
				sequence_DQString(context, (DQString) semanticObject); 
				return; 
			case MyBashPackage.ELSE_IF_BLOCK:
				sequence_ElseIfBlock(context, (ElseIfBlock) semanticObject); 
				return; 
			case MyBashPackage.FOR_STATEMENT:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_ForStatement(context, (ForStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_ForStatement_SimpleList(context, (ForStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getForStatementRule()) {
					sequence_ForStatement(context, (ForStatement) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.FUNCTION_DEFINE:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()
						|| rule == grammarAccess.getFunctionDefineRule()) {
					sequence_FunctionDefine(context, (FunctionDefine) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_FunctionDefine_SimpleList(context, (FunctionDefine) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.GROUP_COMMAND:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_GroupCommand(context, (GroupCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_GroupCommand_SimpleList(context, (GroupCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getGroupCommandRule()) {
					sequence_GroupCommand(context, (GroupCommand) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.IF_STATEMENT:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_IfStatement(context, (IfStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_IfStatement_SimpleList(context, (IfStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getIfStatementRule()) {
					sequence_IfStatement(context, (IfStatement) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.INDEX_EVALUATION:
				if (rule == grammarAccess.getIndexEvaluationStartRule()) {
					sequence_IndexEvaluationStart(context, (IndexEvaluation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIndexEvaluationRule()) {
					sequence_IndexEvaluation_IndexEvaluationStart(context, (IndexEvaluation) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.LASSIGNMENT:
				sequence_LAssignment(context, (LAssignment) semanticObject); 
				return; 
			case MyBashPackage.LITERAL:
				if (rule == grammarAccess.getStringElementRule()
						|| rule == grammarAccess.getLiteralStringPartRule()) {
					sequence_LiteralStringPart(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWordElementRule()
						|| rule == grammarAccess.getLiteralWordPartRule()) {
					sequence_LiteralWordPart(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralWordRule()) {
					sequence_LiteralWord(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.PARAMETER_EXPANSION:
				if (rule == grammarAccess.getParameterExpansionStartRule()) {
					sequence_ParameterExpansionStart(context, (ParameterExpansion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpansionRule()
						|| rule == grammarAccess.getWordElementRule()
						|| rule == grammarAccess.getStringElementRule()
						|| rule == grammarAccess.getParameterExpansionRule()) {
					sequence_ParameterExpansion_ParameterExpansionStart(context, (ParameterExpansion) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case MyBashPackage.PIPELINE:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()) {
					sequence_Pipeline(context, (Pipeline) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Pipeline_SimpleList(context, (Pipeline) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.PIPELINE_COMMAND:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()) {
					sequence_PipelineCommand(context, (PipelineCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_PipelineCommand_SimpleList(context, (PipelineCommand) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.PREFIX_EXPRESSION:
				if (rule == grammarAccess.getEvaluationRule()
						|| action == grammarAccess.getEvaluationAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticRule()
						|| rule == grammarAccess.getConditionalOperatorRule()
						|| action == grammarAccess.getConditionalOperatorAccess().getConditionalOperatorConditionAction_1_1()
						|| rule == grammarAccess.getLogicOrRule()
						|| action == grammarAccess.getLogicOrAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getLogicAndRule()
						|| action == grammarAccess.getLogicAndAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getBitwiseORRule()
						|| action == grammarAccess.getBitwiseORAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getBitwiseExclusiveORRule()
						|| action == grammarAccess.getBitwiseExclusiveORAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getBitwiseANDRule()
						|| action == grammarAccess.getBitwiseANDAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getEqualityAndInequalityRule()
						|| action == grammarAccess.getEqualityAndInequalityAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getBitwiseShiftsRule()
						|| action == grammarAccess.getBitwiseShiftsAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAdditionSubtractionRule()
						|| action == grammarAccess.getAdditionSubtractionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationDivisionRemainderRule()
						|| action == grammarAccess.getMultiplicationDivisionRemainderAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getExponentiationRule()
						|| action == grammarAccess.getExponentiationAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getLogicalAndBitwiseNegationRule()
						|| rule == grammarAccess.getUnaryMinusAndPlusRule()
						|| rule == grammarAccess.getPrimaryItemRule()) {
					sequence_LogicalAndBitwiseNegation_PreDecrement_UnaryMinusAndPlus(context, (PrefixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPreDecrementRule()) {
					sequence_PreDecrement(context, (PrefixExpression) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.PRIMARY_ITEM:
				sequence_PrimaryItem(context, (PrimaryItem) semanticObject); 
				return; 
			case MyBashPackage.PROCESS_SUBSTITUTION:
				if (rule == grammarAccess.getProcessSubstitutionStartRule()) {
					sequence_ProcessSubstitutionStart(context, (ProcessSubstitution) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpansionRule()
						|| rule == grammarAccess.getWordElementRule()
						|| rule == grammarAccess.getStringElementRule()
						|| rule == grammarAccess.getProcessSubstitutionRule()) {
					sequence_ProcessSubstitution_ProcessSubstitutionStart(context, (ProcessSubstitution) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.REDIRECTION:
				sequence_Redirection(context, (Redirection) semanticObject); 
				return; 
			case MyBashPackage.REGULAR_CONST:
				sequence_RegularElements(context, (RegularConst) semanticObject); 
				return; 
			case MyBashPackage.REGULAR_EXPRESSION:
				sequence_RegularExpression(context, (RegularExpression) semanticObject); 
				return; 
			case MyBashPackage.REPLACE_PROCESSOR:
				sequence_ParameterProcessor(context, (ReplaceProcessor) semanticObject); 
				return; 
			case MyBashPackage.SIMPLE_COMMAND:
				if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()
						|| rule == grammarAccess.getSimpleCommandRule()) {
					sequence_SimpleCommand(context, (SimpleCommand) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleListRule()) {
					sequence_SimpleCommand_SimpleList(context, (SimpleCommand) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.SIMPLE_LIST:
				if (rule == grammarAccess.getSimpleListRule()) {
					sequence_SimpleList(context, (SimpleList) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()) {
					sequence_SimpleList_SimpleList_1_0(context, (SimpleList) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.SINGLE_PROCESSOR:
				sequence_ParameterProcessor(context, (SingleProcessor) semanticObject); 
				return; 
			case MyBashPackage.SUB_STRING_PROCESSOR:
				sequence_ParameterProcessor(context, (SubStringProcessor) semanticObject); 
				return; 
			case MyBashPackage.SUBSHELL:
				if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_SimpleList_Subshell(context, (Subshell) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_Subshell(context, (Subshell) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getSubshellRule()) {
					sequence_Subshell(context, (Subshell) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.SUFFIX_EXPRESSION:
				sequence_PostDecrement(context, (SuffixExpression) semanticObject); 
				return; 
			case MyBashPackage.VARIABLE_ID:
				sequence_VariableId(context, (VariableId) semanticObject); 
				return; 
			case MyBashPackage.WHILE_STATEMENT:
				if (rule == grammarAccess.getSimpleListRule()) {
					sequence_Command_SimpleList_WhileStatement(context, (WhileStatement) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getSimpleListAccess().getSimpleListLeftAction_1_0()
						|| rule == grammarAccess.getPipelineCommandRule()
						|| rule == grammarAccess.getPipelineRule()
						|| action == grammarAccess.getPipelineAccess().getPipelineLeftAction_1_0()
						|| rule == grammarAccess.getCommandRule()) {
					sequence_Command_WhileStatement(context, (WhileStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getShellCommandRule()
						|| rule == grammarAccess.getWhileStatementRule()) {
					sequence_WhileStatement(context, (WhileStatement) semanticObject); 
					return; 
				}
				else break;
			case MyBashPackage.WORD:
				if (rule == grammarAccess.getWordRule()
						|| rule == grammarAccess.getAssignableRule()) {
					sequence_Word_Words(context, (Word) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCommandNameRule()
						|| rule == grammarAccess.getWordsRule()) {
					sequence_Words(context, (Word) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Evaluation returns BinaryExpression
	 *     Evaluation.BinaryExpression_1_0 returns BinaryExpression
	 *     Arithmetic returns BinaryExpression
	 *     ConditionalOperator returns BinaryExpression
	 *     ConditionalOperator.ConditionalOperator_1_1 returns BinaryExpression
	 *     LogicOr returns BinaryExpression
	 *     LogicOr.BinaryExpression_1_0 returns BinaryExpression
	 *     LogicAnd returns BinaryExpression
	 *     LogicAnd.BinaryExpression_1_0 returns BinaryExpression
	 *     BitwiseOR returns BinaryExpression
	 *     BitwiseOR.BinaryExpression_1_0 returns BinaryExpression
	 *     BitwiseExclusiveOR returns BinaryExpression
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns BinaryExpression
	 *     BitwiseAND returns BinaryExpression
	 *     BitwiseAND.BinaryExpression_1_0 returns BinaryExpression
	 *     EqualityAndInequality returns BinaryExpression
	 *     EqualityAndInequality.BinaryExpression_1_0 returns BinaryExpression
	 *     Comparison returns BinaryExpression
	 *     Comparison.BinaryExpression_1_0 returns BinaryExpression
	 *     BitwiseShifts returns BinaryExpression
	 *     BitwiseShifts.BinaryExpression_1_0 returns BinaryExpression
	 *     AdditionSubtraction returns BinaryExpression
	 *     AdditionSubtraction.BinaryExpression_1_0 returns BinaryExpression
	 *     MultiplicationDivisionRemainder returns BinaryExpression
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns BinaryExpression
	 *     Exponentiation returns BinaryExpression
	 *     Exponentiation.BinaryExpression_1_0 returns BinaryExpression
	 *     LogicalAndBitwiseNegation returns BinaryExpression
	 *     UnaryMinusAndPlus returns BinaryExpression
	 *     PrimaryItem returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=Evaluation_BinaryExpression_1_0 op=',' right=Arithmetic) | 
	 *         (
	 *             left=VariableId 
	 *             (
	 *                 op='=' | 
	 *                 op='*=' | 
	 *                 op='/=' | 
	 *                 op='%=' | 
	 *                 op='+=' | 
	 *                 op='-=' | 
	 *                 op='<<=' | 
	 *                 op='>>=' | 
	 *                 op='&=' | 
	 *                 op='^=' | 
	 *                 op='|='
	 *             ) 
	 *             right=Arithmetic
	 *         ) | 
	 *         (left=LogicOr_BinaryExpression_1_0 op='||' right=LogicAnd) | 
	 *         (left=LogicAnd_BinaryExpression_1_0 op='&&' right=BitwiseOR) | 
	 *         (left=BitwiseOR_BinaryExpression_1_0 op='|' right=BitwiseExclusiveOR) | 
	 *         (left=BitwiseExclusiveOR_BinaryExpression_1_0 op='^' right=BitwiseAND) | 
	 *         (left=BitwiseAND_BinaryExpression_1_0 op='&' right=EqualityAndInequality) | 
	 *         (left=EqualityAndInequality_BinaryExpression_1_0 (op='==' | op='!=') right=Comparison) | 
	 *         (left=Comparison_BinaryExpression_1_0 (op='<=' | op='>=' | op='<' | op='>') right=BitwiseShifts) | 
	 *         (left=BitwiseShifts_BinaryExpression_1_0 (op='<<' | op='>>') right=AdditionSubtraction) | 
	 *         (left=AdditionSubtraction_BinaryExpression_1_0 (op='+' | op='-') right=MultiplicationDivisionRemainder) | 
	 *         (left=MultiplicationDivisionRemainder_BinaryExpression_1_0 (op='*' | op='/' | op='%') right=Exponentiation) | 
	 *         (left=Exponentiation_BinaryExpression_1_0 op='**' right=Exponentiation)
	 *     )
	 */
	protected void sequence_AdditionSubtraction_Arithmetic_BitwiseAND_BitwiseExclusiveOR_BitwiseOR_BitwiseShifts_Comparison_EqualityAndInequality_Evaluation_Exponentiation_LogicAnd_LogicOr_MultiplicationDivisionRemainder(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns ArithmeticCommand
	 *     ArithmeticCommand returns ArithmeticCommand
	 *
	 * Constraint:
	 *     expression=Evaluation
	 */
	protected void sequence_ArithmeticCommand(ISerializationContext context, ArithmeticCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.ARITHMETIC_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.ARITHMETIC_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticCommandAccess().getExpressionEvaluationParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns ArithmeticCommand
	 *     PipelineCommand returns ArithmeticCommand
	 *     Pipeline returns ArithmeticCommand
	 *     Pipeline.Pipeline_1_0 returns ArithmeticCommand
	 *     Command returns ArithmeticCommand
	 *
	 * Constraint:
	 *     (expression=Evaluation redirects+=Redirection*)
	 */
	protected void sequence_ArithmeticCommand_Command(ISerializationContext context, ArithmeticCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns ArithmeticCommand
	 *
	 * Constraint:
	 *     (expression=Evaluation redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_ArithmeticCommand_Command_SimpleList(ISerializationContext context, ArithmeticCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expansion returns ArithmeticExpansion
	 *     WordElement returns ArithmeticExpansion
	 *     StringElement returns ArithmeticExpansion
	 *     ArithmeticExpansion returns ArithmeticExpansion
	 *     ArithmeticExpansionStart returns ArithmeticExpansion
	 *
	 * Constraint:
	 *     expression=Evaluation
	 */
	protected void sequence_ArithmeticExpansionStart(ISerializationContext context, ArithmeticExpansion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.ARITHMETIC_EXPANSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.ARITHMETIC_EXPANSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpansionStartAccess().getExpressionEvaluationParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Array returns Array
	 *     ArrayStart returns Array
	 *     Assignable returns Array
	 *
	 * Constraint:
	 *     words+=Word*
	 */
	protected void sequence_ArrayStart(ISerializationContext context, Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (name=NAME index=IndexEvaluation? value=Assignable?)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Bash returns Bash
	 *
	 * Constraint:
	 *     ((commands+=SimpleList commands+=SimpleList*) | error?=Word | error?=Assignment)?
	 */
	protected void sequence_Bash(ISerializationContext context, Bash semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CasePatternContinue returns CasePattern
	 *
	 * Constraint:
	 *     ((follow=';;' | follow=';&' | follow=';;&') condition=Pattern body=CompoundList)
	 */
	protected void sequence_CasePatternContinue(ISerializationContext context, CasePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CasePattern returns CasePattern
	 *
	 * Constraint:
	 *     (condition=Pattern body=CompoundList)
	 */
	protected void sequence_CasePattern(ISerializationContext context, CasePattern semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.CASE_PATTERN__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.CASE_PATTERN__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.CASE_PATTERN__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.CASE_PATTERN__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCasePatternAccess().getConditionPatternParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getCasePatternAccess().getBodyCompoundListParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns CaseStatement
	 *     CaseStatement returns CaseStatement
	 *
	 * Constraint:
	 *     (variable=Word (patterns+=CasePattern patterns+=CasePatternContinue*)?)
	 */
	protected void sequence_CaseStatement(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns CaseStatement
	 *     PipelineCommand returns CaseStatement
	 *     Pipeline returns CaseStatement
	 *     Pipeline.Pipeline_1_0 returns CaseStatement
	 *     Command returns CaseStatement
	 *
	 * Constraint:
	 *     (variable=Word (patterns+=CasePattern patterns+=CasePatternContinue*)? redirects+=Redirection*)
	 */
	protected void sequence_CaseStatement_Command(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns CaseStatement
	 *
	 * Constraint:
	 *     (variable=Word (patterns+=CasePattern patterns+=CasePatternContinue*)? redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_CaseStatement_Command_SimpleList(ISerializationContext context, CaseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandName returns CommandName
	 *
	 * Constraint:
	 *     ref=[FunctionDefine|FunctionName]
	 */
	protected void sequence_CommandName(ISerializationContext context, CommandName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.COMMAND_NAME__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.COMMAND_NAME__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandNameAccess().getRefFunctionDefineFunctionNameParserRuleCall_0_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CommandSubstitutionStart returns CommandSubstitution
	 *
	 * Constraint:
	 *     commands=CompoundList
	 */
	protected void sequence_CommandSubstitutionStart(ISerializationContext context, CommandSubstitution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.COMMAND_SUBSTITUTION__COMMANDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.COMMAND_SUBSTITUTION__COMMANDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandSubstitutionStartAccess().getCommandsCompoundListParserRuleCall_1_0(), semanticObject.getCommands());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expansion returns CommandSubstitution
	 *     WordElement returns CommandSubstitution
	 *     StringElement returns CommandSubstitution
	 *     CommandSubstitution returns CommandSubstitution
	 *
	 * Constraint:
	 *     (commands=CompoundList end=CommandSubstitutionStartEnd)
	 */
	protected void sequence_CommandSubstitution_CommandSubstitutionStart(ISerializationContext context, CommandSubstitution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.COMMAND_SUBSTITUTION__COMMANDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.COMMAND_SUBSTITUTION__COMMANDS));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.COMMAND_SUBSTITUTION__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.COMMAND_SUBSTITUTION__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandSubstitutionStartAccess().getCommandsCompoundListParserRuleCall_1_0(), semanticObject.getCommands());
		feeder.accept(grammarAccess.getCommandSubstitutionAccess().getEndCommandSubstitutionStartEndParserRuleCall_1_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns CondCommand
	 *     PipelineCommand returns CondCommand
	 *     Pipeline returns CondCommand
	 *     Pipeline.Pipeline_1_0 returns CondCommand
	 *     Command returns CondCommand
	 *
	 * Constraint:
	 *     (expression=CondOrAnd redirects+=Redirection*)
	 */
	protected void sequence_Command_CondCommand(ISerializationContext context, CondCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns CondCommand
	 *
	 * Constraint:
	 *     (expression=CondOrAnd redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_Command_CondCommand_SimpleList(ISerializationContext context, CondCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns ArithmeticForStatement
	 *     PipelineCommand returns ArithmeticForStatement
	 *     Pipeline returns ArithmeticForStatement
	 *     Pipeline.Pipeline_1_0 returns ArithmeticForStatement
	 *     Command returns ArithmeticForStatement
	 *
	 * Constraint:
	 *     (init=Evaluation? condition=Evaluation? step=Evaluation? body=CompoundList redirects+=Redirection*)
	 */
	protected void sequence_Command_ForStatement(ISerializationContext context, ArithmeticForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns ForStatement
	 *     PipelineCommand returns ForStatement
	 *     Pipeline returns ForStatement
	 *     Pipeline.Pipeline_1_0 returns ForStatement
	 *     Command returns ForStatement
	 *
	 * Constraint:
	 *     (variable=NAME words+=Word+ body=CompoundList redirects+=Redirection*)
	 */
	protected void sequence_Command_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns ArithmeticForStatement
	 *
	 * Constraint:
	 *     (
	 *         init=Evaluation? 
	 *         condition=Evaluation? 
	 *         step=Evaluation? 
	 *         body=CompoundList 
	 *         redirects+=Redirection* 
	 *         backend?='&'?
	 *     )
	 */
	protected void sequence_Command_ForStatement_SimpleList(ISerializationContext context, ArithmeticForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns ForStatement
	 *
	 * Constraint:
	 *     (variable=NAME words+=Word+ body=CompoundList redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_Command_ForStatement_SimpleList(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns GroupCommand
	 *     PipelineCommand returns GroupCommand
	 *     Pipeline returns GroupCommand
	 *     Pipeline.Pipeline_1_0 returns GroupCommand
	 *     Command returns GroupCommand
	 *
	 * Constraint:
	 *     (body=CompoundList redirects+=Redirection*)
	 */
	protected void sequence_Command_GroupCommand(ISerializationContext context, GroupCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns GroupCommand
	 *
	 * Constraint:
	 *     (body=CompoundList redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_Command_GroupCommand_SimpleList(ISerializationContext context, GroupCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns IfStatement
	 *     PipelineCommand returns IfStatement
	 *     Pipeline returns IfStatement
	 *     Pipeline.Pipeline_1_0 returns IfStatement
	 *     Command returns IfStatement
	 *
	 * Constraint:
	 *     (condition=CompoundList then=CompoundList elseIfBlock+=ElseIfBlock* else=CompoundList? redirects+=Redirection*)
	 */
	protected void sequence_Command_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns IfStatement
	 *
	 * Constraint:
	 *     (
	 *         condition=CompoundList 
	 *         then=CompoundList 
	 *         elseIfBlock+=ElseIfBlock* 
	 *         else=CompoundList? 
	 *         redirects+=Redirection* 
	 *         backend?='&'?
	 *     )
	 */
	protected void sequence_Command_IfStatement_SimpleList(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns Subshell
	 *
	 * Constraint:
	 *     (body=CompoundList redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_Command_SimpleList_Subshell(ISerializationContext context, Subshell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns WhileStatement
	 *
	 * Constraint:
	 *     (c=CompoundList d=CompoundList redirects+=Redirection* backend?='&'?)
	 */
	protected void sequence_Command_SimpleList_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns Subshell
	 *     PipelineCommand returns Subshell
	 *     Pipeline returns Subshell
	 *     Pipeline.Pipeline_1_0 returns Subshell
	 *     Command returns Subshell
	 *
	 * Constraint:
	 *     (body=CompoundList redirects+=Redirection*)
	 */
	protected void sequence_Command_Subshell(ISerializationContext context, Subshell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns WhileStatement
	 *     PipelineCommand returns WhileStatement
	 *     Pipeline returns WhileStatement
	 *     Pipeline.Pipeline_1_0 returns WhileStatement
	 *     Command returns WhileStatement
	 *
	 * Constraint:
	 *     (c=CompoundList d=CompoundList redirects+=Redirection*)
	 */
	protected void sequence_Command_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompoundList returns CompoundList
	 *
	 * Constraint:
	 *     (commands+=SimpleList commands+=SimpleList*)
	 */
	protected void sequence_CompoundList(ISerializationContext context, CompoundList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns CondCommand
	 *     CondCommand returns CondCommand
	 *
	 * Constraint:
	 *     expression=CondOrAnd
	 */
	protected void sequence_CondCommand(ISerializationContext context, CondCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.COND_COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.COND_COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCondCommandAccess().getExpressionCondOrAndParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CondOrAnd returns CondConst
	 *     CondOrAnd.CondUnaryExpression_1_0 returns CondConst
	 *     CondExp returns CondConst
	 *     CondExp.CondBinaryExpression_1_1_0 returns CondConst
	 *     CondConst returns CondConst
	 *
	 * Constraint:
	 *     value=Word
	 */
	protected void sequence_CondConst(ISerializationContext context, CondConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.COND_CONST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.COND_CONST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCondConstAccess().getValueWordParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CondOrAnd returns CondBinaryExpression
	 *     CondOrAnd.CondUnaryExpression_1_0 returns CondBinaryExpression
	 *     CondExp returns CondBinaryExpression
	 *
	 * Constraint:
	 *     (left=CondExp_CondBinaryExpression_1_1_0 ((op=C_B_OP right=Word) | (op='=~' right=RegularExpression)))
	 */
	protected void sequence_CondExp(ISerializationContext context, CondBinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CondOrAnd returns CondUnaryExpression
	 *     CondOrAnd.CondUnaryExpression_1_0 returns CondUnaryExpression
	 *     CondExp returns CondUnaryExpression
	 *
	 * Constraint:
	 *     ((left=CondOrAnd_CondUnaryExpression_1_0 right=CondExp) | (op=C_S_OP operand=Word))
	 */
	protected void sequence_CondExp_CondOrAnd(ISerializationContext context, CondUnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns ConditionalOperator
	 *     Evaluation.BinaryExpression_1_0 returns ConditionalOperator
	 *     Arithmetic returns ConditionalOperator
	 *     ConditionalOperator returns ConditionalOperator
	 *     ConditionalOperator.ConditionalOperator_1_1 returns ConditionalOperator
	 *     LogicOr returns ConditionalOperator
	 *     LogicOr.BinaryExpression_1_0 returns ConditionalOperator
	 *     LogicAnd returns ConditionalOperator
	 *     LogicAnd.BinaryExpression_1_0 returns ConditionalOperator
	 *     BitwiseOR returns ConditionalOperator
	 *     BitwiseOR.BinaryExpression_1_0 returns ConditionalOperator
	 *     BitwiseExclusiveOR returns ConditionalOperator
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns ConditionalOperator
	 *     BitwiseAND returns ConditionalOperator
	 *     BitwiseAND.BinaryExpression_1_0 returns ConditionalOperator
	 *     EqualityAndInequality returns ConditionalOperator
	 *     EqualityAndInequality.BinaryExpression_1_0 returns ConditionalOperator
	 *     Comparison returns ConditionalOperator
	 *     Comparison.BinaryExpression_1_0 returns ConditionalOperator
	 *     BitwiseShifts returns ConditionalOperator
	 *     BitwiseShifts.BinaryExpression_1_0 returns ConditionalOperator
	 *     AdditionSubtraction returns ConditionalOperator
	 *     AdditionSubtraction.BinaryExpression_1_0 returns ConditionalOperator
	 *     MultiplicationDivisionRemainder returns ConditionalOperator
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns ConditionalOperator
	 *     Exponentiation returns ConditionalOperator
	 *     Exponentiation.BinaryExpression_1_0 returns ConditionalOperator
	 *     LogicalAndBitwiseNegation returns ConditionalOperator
	 *     UnaryMinusAndPlus returns ConditionalOperator
	 *     PrimaryItem returns ConditionalOperator
	 *
	 * Constraint:
	 *     (condition=ConditionalOperator_ConditionalOperator_1_1 first=ConditionalOperator right=ConditionalOperator)
	 */
	protected void sequence_ConditionalOperator(ISerializationContext context, ConditionalOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.CONDITIONAL_OPERATOR__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.CONDITIONAL_OPERATOR__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.CONDITIONAL_OPERATOR__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.CONDITIONAL_OPERATOR__FIRST));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.CONDITIONAL_OPERATOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.CONDITIONAL_OPERATOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalOperatorAccess().getConditionalOperatorConditionAction_1_1(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalOperatorAccess().getFirstConditionalOperatorParserRuleCall_1_2_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getConditionalOperatorAccess().getRightConditionalOperatorParserRuleCall_1_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DQString returns DQString
	 *     WordElement returns DQString
	 *
	 * Constraint:
	 *     elements+=StringElement*
	 */
	protected void sequence_DQString(ISerializationContext context, DQString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIfBlock returns ElseIfBlock
	 *
	 * Constraint:
	 *     (condition=CompoundList then=CompoundList)
	 */
	protected void sequence_ElseIfBlock(ISerializationContext context, ElseIfBlock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.ELSE_IF_BLOCK__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.ELSE_IF_BLOCK__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.ELSE_IF_BLOCK__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.ELSE_IF_BLOCK__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseIfBlockAccess().getConditionCompoundListParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getElseIfBlockAccess().getThenCompoundListParserRuleCall_4_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns ArithmeticForStatement
	 *     ForStatement returns ArithmeticForStatement
	 *
	 * Constraint:
	 *     (init=Evaluation? condition=Evaluation? step=Evaluation? body=CompoundList)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ArithmeticForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (variable=NAME words+=Word+ body=CompoundList)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns FunctionDefine
	 *     PipelineCommand returns FunctionDefine
	 *     Pipeline returns FunctionDefine
	 *     Pipeline.Pipeline_1_0 returns FunctionDefine
	 *     Command returns FunctionDefine
	 *     FunctionDefine returns FunctionDefine
	 *
	 * Constraint:
	 *     ((name=FunctionName body=ShellCommand) | (name=FunctionName body=ShellCommand))
	 */
	protected void sequence_FunctionDefine(ISerializationContext context, FunctionDefine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns FunctionDefine
	 *
	 * Constraint:
	 *     (((name=FunctionName body=ShellCommand) | (name=FunctionName body=ShellCommand)) backend?='&'?)
	 */
	protected void sequence_FunctionDefine_SimpleList(ISerializationContext context, FunctionDefine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns GroupCommand
	 *     GroupCommand returns GroupCommand
	 *
	 * Constraint:
	 *     body=CompoundList
	 */
	protected void sequence_GroupCommand(ISerializationContext context, GroupCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.GROUP_COMMAND__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.GROUP_COMMAND__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupCommandAccess().getBodyCompoundListParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=CompoundList then=CompoundList elseIfBlock+=ElseIfBlock* else=CompoundList?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IndexEvaluationStart returns IndexEvaluation
	 *
	 * Constraint:
	 *     expression=Evaluation
	 */
	protected void sequence_IndexEvaluationStart(ISerializationContext context, IndexEvaluation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.INDEX_EVALUATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.INDEX_EVALUATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexEvaluationStartAccess().getExpressionEvaluationParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IndexEvaluation returns IndexEvaluation
	 *
	 * Constraint:
	 *     (expression=Evaluation end=IndexEvaluationEnd)
	 */
	protected void sequence_IndexEvaluation_IndexEvaluationStart(ISerializationContext context, IndexEvaluation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.INDEX_EVALUATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.INDEX_EVALUATION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.INDEX_EVALUATION__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.INDEX_EVALUATION__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexEvaluationStartAccess().getExpressionEvaluationParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getIndexEvaluationAccess().getEndIndexEvaluationEndParserRuleCall_1_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LAssignment returns LAssignment
	 *
	 * Constraint:
	 *     (name=NAME index=IndexEvaluation? value=Assignable?)
	 */
	protected void sequence_LAssignment(ISerializationContext context, LAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringElement returns Literal
	 *     LiteralStringPart returns Literal
	 *
	 * Constraint:
	 *     values+=WORD_PART+
	 */
	protected void sequence_LiteralStringPart(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordElement returns Literal
	 *     LiteralWordPart returns Literal
	 *
	 * Constraint:
	 *     (values+=WORD_PART | values+=WORD_PART | values+=WORD_PART)*
	 */
	protected void sequence_LiteralWordPart(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralWord returns Literal
	 *
	 * Constraint:
	 *     values+=S_WORD_PART
	 */
	protected void sequence_LiteralWord(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns PrefixExpression
	 *     Evaluation.BinaryExpression_1_0 returns PrefixExpression
	 *     Arithmetic returns PrefixExpression
	 *     ConditionalOperator returns PrefixExpression
	 *     ConditionalOperator.ConditionalOperator_1_1 returns PrefixExpression
	 *     LogicOr returns PrefixExpression
	 *     LogicOr.BinaryExpression_1_0 returns PrefixExpression
	 *     LogicAnd returns PrefixExpression
	 *     LogicAnd.BinaryExpression_1_0 returns PrefixExpression
	 *     BitwiseOR returns PrefixExpression
	 *     BitwiseOR.BinaryExpression_1_0 returns PrefixExpression
	 *     BitwiseExclusiveOR returns PrefixExpression
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns PrefixExpression
	 *     BitwiseAND returns PrefixExpression
	 *     BitwiseAND.BinaryExpression_1_0 returns PrefixExpression
	 *     EqualityAndInequality returns PrefixExpression
	 *     EqualityAndInequality.BinaryExpression_1_0 returns PrefixExpression
	 *     Comparison returns PrefixExpression
	 *     Comparison.BinaryExpression_1_0 returns PrefixExpression
	 *     BitwiseShifts returns PrefixExpression
	 *     BitwiseShifts.BinaryExpression_1_0 returns PrefixExpression
	 *     AdditionSubtraction returns PrefixExpression
	 *     AdditionSubtraction.BinaryExpression_1_0 returns PrefixExpression
	 *     MultiplicationDivisionRemainder returns PrefixExpression
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns PrefixExpression
	 *     Exponentiation returns PrefixExpression
	 *     Exponentiation.BinaryExpression_1_0 returns PrefixExpression
	 *     LogicalAndBitwiseNegation returns PrefixExpression
	 *     UnaryMinusAndPlus returns PrefixExpression
	 *     PrimaryItem returns PrefixExpression
	 *
	 * Constraint:
	 *     (
	 *         ((op='!' | op='~') operand=LogicalAndBitwiseNegation) | 
	 *         ((op='+' | op='-') operand=UnaryMinusAndPlus) | 
	 *         ((op='++' | op='--') operand=PostDecrement)
	 *     )
	 */
	protected void sequence_LogicalAndBitwiseNegation_PreDecrement_UnaryMinusAndPlus(ISerializationContext context, PrefixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterExpansionStart returns ParameterExpansion
	 *
	 * Constraint:
	 *     (hash?='#'? (ref=[Assignment|NAME] | value=I_NUMBER | value='?' | value='@' | value='*') index=Evaluation? replacer=ParameterProcessor?)
	 */
	protected void sequence_ParameterExpansionStart(ISerializationContext context, ParameterExpansion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expansion returns ParameterExpansion
	 *     WordElement returns ParameterExpansion
	 *     StringElement returns ParameterExpansion
	 *     ParameterExpansion returns ParameterExpansion
	 *
	 * Constraint:
	 *     (
	 *         ref=[Assignment|VARIABLE] | 
	 *         (
	 *             hash?='#'? 
	 *             (ref=[Assignment|NAME] | value=I_NUMBER | value='?' | value='@' | value='*') 
	 *             index=Evaluation? 
	 *             replacer=ParameterProcessor? 
	 *             end=ParameterExpansionEnd
	 *         )
	 *     )
	 */
	protected void sequence_ParameterExpansion_ParameterExpansionStart(ISerializationContext context, ParameterExpansion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterProcessor returns ReplaceProcessor
	 *
	 * Constraint:
	 *     (((op='//' | op='/') (original=Word replace=Word?)?) | ((op='//' | op='/') replace=Word?))
	 */
	protected void sequence_ParameterProcessor(ISerializationContext context, ReplaceProcessor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterProcessor returns SingleProcessor
	 *
	 * Constraint:
	 *     (op=FollowWordOp word=Word?)
	 */
	protected void sequence_ParameterProcessor(ISerializationContext context, SingleProcessor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterProcessor returns SubStringProcessor
	 *
	 * Constraint:
	 *     ((start=Evaluation length=Evaluation?) | length=Evaluation)?
	 */
	protected void sequence_ParameterProcessor(ISerializationContext context, SubStringProcessor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (parts+=Word parts+=Word*)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns PipelineCommand
	 *     PipelineCommand returns PipelineCommand
	 *
	 * Constraint:
	 *     (not?='!' pipeline=Pipeline)
	 */
	protected void sequence_PipelineCommand(ISerializationContext context, PipelineCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.PIPELINE_COMMAND__NOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.PIPELINE_COMMAND__NOT));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.PIPELINE_COMMAND__PIPELINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.PIPELINE_COMMAND__PIPELINE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPipelineCommandAccess().getNotExclamationMarkKeyword_0_1_0(), semanticObject.isNot());
		feeder.accept(grammarAccess.getPipelineCommandAccess().getPipelinePipelineParserRuleCall_0_2_0(), semanticObject.getPipeline());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns PipelineCommand
	 *
	 * Constraint:
	 *     (not?='!' pipeline=Pipeline backend?='&'?)
	 */
	protected void sequence_PipelineCommand_SimpleList(ISerializationContext context, PipelineCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns Pipeline
	 *     PipelineCommand returns Pipeline
	 *     Pipeline returns Pipeline
	 *     Pipeline.Pipeline_1_0 returns Pipeline
	 *
	 * Constraint:
	 *     (left=Pipeline_Pipeline_1_0 (op='|' | op='|&') right=Command)
	 */
	protected void sequence_Pipeline(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns Pipeline
	 *
	 * Constraint:
	 *     (left=Pipeline_Pipeline_1_0 (op='|' | op='|&') right=Command backend?='&'?)
	 */
	protected void sequence_Pipeline_SimpleList(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns SuffixExpression
	 *     Evaluation.BinaryExpression_1_0 returns SuffixExpression
	 *     Arithmetic returns SuffixExpression
	 *     ConditionalOperator returns SuffixExpression
	 *     ConditionalOperator.ConditionalOperator_1_1 returns SuffixExpression
	 *     LogicOr returns SuffixExpression
	 *     LogicOr.BinaryExpression_1_0 returns SuffixExpression
	 *     LogicAnd returns SuffixExpression
	 *     LogicAnd.BinaryExpression_1_0 returns SuffixExpression
	 *     BitwiseOR returns SuffixExpression
	 *     BitwiseOR.BinaryExpression_1_0 returns SuffixExpression
	 *     BitwiseExclusiveOR returns SuffixExpression
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns SuffixExpression
	 *     BitwiseAND returns SuffixExpression
	 *     BitwiseAND.BinaryExpression_1_0 returns SuffixExpression
	 *     EqualityAndInequality returns SuffixExpression
	 *     EqualityAndInequality.BinaryExpression_1_0 returns SuffixExpression
	 *     Comparison returns SuffixExpression
	 *     Comparison.BinaryExpression_1_0 returns SuffixExpression
	 *     BitwiseShifts returns SuffixExpression
	 *     BitwiseShifts.BinaryExpression_1_0 returns SuffixExpression
	 *     AdditionSubtraction returns SuffixExpression
	 *     AdditionSubtraction.BinaryExpression_1_0 returns SuffixExpression
	 *     MultiplicationDivisionRemainder returns SuffixExpression
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns SuffixExpression
	 *     Exponentiation returns SuffixExpression
	 *     Exponentiation.BinaryExpression_1_0 returns SuffixExpression
	 *     LogicalAndBitwiseNegation returns SuffixExpression
	 *     UnaryMinusAndPlus returns SuffixExpression
	 *     PreDecrement returns SuffixExpression
	 *     PostDecrement returns SuffixExpression
	 *     PrimaryItem returns SuffixExpression
	 *
	 * Constraint:
	 *     (operand=PostDecrement_SuffixExpression_1_0 (op='++' | op='--'))
	 */
	protected void sequence_PostDecrement(ISerializationContext context, SuffixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PreDecrement returns PrefixExpression
	 *
	 * Constraint:
	 *     ((op='++' | op='--') operand=PostDecrement)
	 */
	protected void sequence_PreDecrement(ISerializationContext context, PrefixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns ConstPrimaryItem
	 *     Evaluation.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     Arithmetic returns ConstPrimaryItem
	 *     ConditionalOperator returns ConstPrimaryItem
	 *     ConditionalOperator.ConditionalOperator_1_1 returns ConstPrimaryItem
	 *     LogicOr returns ConstPrimaryItem
	 *     LogicOr.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     LogicAnd returns ConstPrimaryItem
	 *     LogicAnd.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     BitwiseOR returns ConstPrimaryItem
	 *     BitwiseOR.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     BitwiseExclusiveOR returns ConstPrimaryItem
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     BitwiseAND returns ConstPrimaryItem
	 *     BitwiseAND.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     EqualityAndInequality returns ConstPrimaryItem
	 *     EqualityAndInequality.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     Comparison returns ConstPrimaryItem
	 *     Comparison.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     BitwiseShifts returns ConstPrimaryItem
	 *     BitwiseShifts.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     AdditionSubtraction returns ConstPrimaryItem
	 *     AdditionSubtraction.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     MultiplicationDivisionRemainder returns ConstPrimaryItem
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     Exponentiation returns ConstPrimaryItem
	 *     Exponentiation.BinaryExpression_1_0 returns ConstPrimaryItem
	 *     LogicalAndBitwiseNegation returns ConstPrimaryItem
	 *     UnaryMinusAndPlus returns ConstPrimaryItem
	 *     PrimaryItem returns ConstPrimaryItem
	 *
	 * Constraint:
	 *     (prefix=A_PREFIX? value=I_NUMBER)
	 */
	protected void sequence_PrimaryItem(ISerializationContext context, ConstPrimaryItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns PrimaryItem
	 *     Evaluation.BinaryExpression_1_0 returns PrimaryItem
	 *     Arithmetic returns PrimaryItem
	 *     ConditionalOperator returns PrimaryItem
	 *     ConditionalOperator.ConditionalOperator_1_1 returns PrimaryItem
	 *     LogicOr returns PrimaryItem
	 *     LogicOr.BinaryExpression_1_0 returns PrimaryItem
	 *     LogicAnd returns PrimaryItem
	 *     LogicAnd.BinaryExpression_1_0 returns PrimaryItem
	 *     BitwiseOR returns PrimaryItem
	 *     BitwiseOR.BinaryExpression_1_0 returns PrimaryItem
	 *     BitwiseExclusiveOR returns PrimaryItem
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns PrimaryItem
	 *     BitwiseAND returns PrimaryItem
	 *     BitwiseAND.BinaryExpression_1_0 returns PrimaryItem
	 *     EqualityAndInequality returns PrimaryItem
	 *     EqualityAndInequality.BinaryExpression_1_0 returns PrimaryItem
	 *     Comparison returns PrimaryItem
	 *     Comparison.BinaryExpression_1_0 returns PrimaryItem
	 *     BitwiseShifts returns PrimaryItem
	 *     BitwiseShifts.BinaryExpression_1_0 returns PrimaryItem
	 *     AdditionSubtraction returns PrimaryItem
	 *     AdditionSubtraction.BinaryExpression_1_0 returns PrimaryItem
	 *     MultiplicationDivisionRemainder returns PrimaryItem
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns PrimaryItem
	 *     Exponentiation returns PrimaryItem
	 *     Exponentiation.BinaryExpression_1_0 returns PrimaryItem
	 *     LogicalAndBitwiseNegation returns PrimaryItem
	 *     UnaryMinusAndPlus returns PrimaryItem
	 *     PrimaryItem returns PrimaryItem
	 *
	 * Constraint:
	 *     (prefix=A_PREFIX? value=Expansion)
	 */
	protected void sequence_PrimaryItem(ISerializationContext context, PrimaryItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessSubstitutionStart returns ProcessSubstitution
	 *
	 * Constraint:
	 *     ((op='<(' | op='>(') body=CompoundList)
	 */
	protected void sequence_ProcessSubstitutionStart(ISerializationContext context, ProcessSubstitution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expansion returns ProcessSubstitution
	 *     WordElement returns ProcessSubstitution
	 *     StringElement returns ProcessSubstitution
	 *     ProcessSubstitution returns ProcessSubstitution
	 *
	 * Constraint:
	 *     ((op='<(' | op='>(') body=CompoundList end=ProcessSubstitutionEnd)
	 */
	protected void sequence_ProcessSubstitution_ProcessSubstitutionStart(ISerializationContext context, ProcessSubstitution semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Redirection returns Redirection
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 op='>&' | 
	 *                 op='>' | 
	 *                 op='>>' | 
	 *                 op='<' | 
	 *                 op='<&' | 
	 *                 op='&>>' | 
	 *                 op='<>' | 
	 *                 op='&>' | 
	 *                 op='<|' | 
	 *                 op='>|'
	 *             ) 
	 *             target=Word?
	 *         ) | 
	 *         op='<<'
	 *     )
	 */
	protected void sequence_Redirection(ISerializationContext context, Redirection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularExpression returns RegularConst
	 *     RegularExpression.RegularExpression_1_0 returns RegularConst
	 *     RegularElements returns RegularConst
	 *
	 * Constraint:
	 *     (parts+=Word | parts+=Word)*
	 */
	protected void sequence_RegularElements(ISerializationContext context, RegularConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegularExpression returns RegularExpression
	 *     RegularExpression.RegularExpression_1_0 returns RegularExpression
	 *
	 * Constraint:
	 *     (left=RegularExpression_RegularExpression_1_0 op='|' right=RegularElements)
	 */
	protected void sequence_RegularExpression(ISerializationContext context, RegularExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.REGULAR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.REGULAR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.REGULAR_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.REGULAR_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.REGULAR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.REGULAR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularExpressionAccess().getRegularExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRegularExpressionAccess().getOpVerticalLineKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getRegularExpressionAccess().getRightRegularElementsParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns SimpleCommand
	 *     PipelineCommand returns SimpleCommand
	 *     Pipeline returns SimpleCommand
	 *     Pipeline.Pipeline_1_0 returns SimpleCommand
	 *     Command returns SimpleCommand
	 *     SimpleCommand returns SimpleCommand
	 *
	 * Constraint:
	 *     (
	 *         (assignments+=Assignment+ (command=CommandName (parameters+=Word | r+=Redirection)*)?) | 
	 *         (command=CommandName (parameters+=Word | parameters+=LAssignment | r+=Redirection)*) | 
	 *         r+=Redirection+
	 *     )
	 */
	protected void sequence_SimpleCommand(ISerializationContext context, SimpleCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns SimpleCommand
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (assignments+=Assignment+ (command=CommandName (parameters+=Word | r+=Redirection)*)?) | 
	 *             (command=CommandName (parameters+=Word | parameters+=LAssignment | r+=Redirection)*) | 
	 *             r+=Redirection+
	 *         ) 
	 *         backend?='&'?
	 *     )
	 */
	protected void sequence_SimpleCommand_SimpleList(ISerializationContext context, SimpleCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList returns SimpleList
	 *
	 * Constraint:
	 *     (left=SimpleList_SimpleList_1_0 (op='&&' | op='||' | op='&' | op=';') right=PipelineCommand backend?='&'?)
	 */
	protected void sequence_SimpleList(ISerializationContext context, SimpleList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleList.SimpleList_1_0 returns SimpleList
	 *
	 * Constraint:
	 *     (left=SimpleList_SimpleList_1_0 (op='&&' | op='||' | op='&' | op=';') right=PipelineCommand)
	 */
	protected void sequence_SimpleList_SimpleList_1_0(ISerializationContext context, SimpleList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns Subshell
	 *     Subshell returns Subshell
	 *
	 * Constraint:
	 *     body=CompoundList
	 */
	protected void sequence_Subshell(ISerializationContext context, Subshell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.SUBSHELL__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.SUBSHELL__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubshellAccess().getBodyCompoundListParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns VariableId
	 *     Evaluation.BinaryExpression_1_0 returns VariableId
	 *     Arithmetic returns VariableId
	 *     ConditionalOperator returns VariableId
	 *     ConditionalOperator.ConditionalOperator_1_1 returns VariableId
	 *     LogicOr returns VariableId
	 *     LogicOr.BinaryExpression_1_0 returns VariableId
	 *     LogicAnd returns VariableId
	 *     LogicAnd.BinaryExpression_1_0 returns VariableId
	 *     BitwiseOR returns VariableId
	 *     BitwiseOR.BinaryExpression_1_0 returns VariableId
	 *     BitwiseExclusiveOR returns VariableId
	 *     BitwiseExclusiveOR.BinaryExpression_1_0 returns VariableId
	 *     BitwiseAND returns VariableId
	 *     BitwiseAND.BinaryExpression_1_0 returns VariableId
	 *     EqualityAndInequality returns VariableId
	 *     EqualityAndInequality.BinaryExpression_1_0 returns VariableId
	 *     Comparison returns VariableId
	 *     Comparison.BinaryExpression_1_0 returns VariableId
	 *     BitwiseShifts returns VariableId
	 *     BitwiseShifts.BinaryExpression_1_0 returns VariableId
	 *     AdditionSubtraction returns VariableId
	 *     AdditionSubtraction.BinaryExpression_1_0 returns VariableId
	 *     MultiplicationDivisionRemainder returns VariableId
	 *     MultiplicationDivisionRemainder.BinaryExpression_1_0 returns VariableId
	 *     Exponentiation returns VariableId
	 *     Exponentiation.BinaryExpression_1_0 returns VariableId
	 *     LogicalAndBitwiseNegation returns VariableId
	 *     UnaryMinusAndPlus returns VariableId
	 *     PreDecrement returns VariableId
	 *     PostDecrement returns VariableId
	 *     PostDecrement.SuffixExpression_1_0 returns VariableId
	 *     PrimaryItem returns VariableId
	 *     VariableId returns VariableId
	 *
	 * Constraint:
	 *     ref=[Assignment|NAME]
	 */
	protected void sequence_VariableId(ISerializationContext context, VariableId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.VARIABLE_ID__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.VARIABLE_ID__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableIdAccess().getRefAssignmentNAMETerminalRuleCall_1_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ShellCommand returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (c=CompoundList d=CompoundList)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.WHILE_STATEMENT__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.WHILE_STATEMENT__C));
			if (transientValues.isValueTransient(semanticObject, MyBashPackage.Literals.WHILE_STATEMENT__D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyBashPackage.Literals.WHILE_STATEMENT__D));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getCCompoundListParserRuleCall_1_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getWhileStatementAccess().getDCompoundListParserRuleCall_3_0(), semanticObject.getD());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Word returns Word
	 *     Assignable returns Word
	 *
	 * Constraint:
	 *     (elements+=LiteralWord | elements+=WordElement+)
	 */
	protected void sequence_Word_Words(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommandName returns Word
	 *     Words returns Word
	 *
	 * Constraint:
	 *     elements+=WordElement+
	 */
	protected void sequence_Words(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
