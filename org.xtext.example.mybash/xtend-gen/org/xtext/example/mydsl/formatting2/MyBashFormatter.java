/**
 * generated by Xtext 2.9.1
 */
package org.xtext.example.mydsl.formatting2;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.Arrays;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatting;
import org.eclipse.xtext.formatting2.ITextReplacer;
import org.eclipse.xtext.formatting2.internal.RootDocument;
import org.eclipse.xtext.formatting2.internal.SinglelineCodeCommentReplacer;
import org.eclipse.xtext.formatting2.internal.WhitespaceReplacer;
import org.eclipse.xtext.formatting2.regionaccess.IComment;
import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegion;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegionsFinder;
import org.eclipse.xtext.formatting2.regionaccess.ITextSegment;
import org.eclipse.xtext.grammaranalysis.impl.GrammarElementTitleSwitch;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.xtext.example.mydsl.formatting2.MyBashWhitespaceReplacer;
import org.xtext.example.mydsl.myBash.Assignment;
import org.xtext.example.mydsl.myBash.CommandUnit;
import org.xtext.example.mydsl.myBash.CompoundList;
import org.xtext.example.mydsl.myBash.ElseIfBlock;
import org.xtext.example.mydsl.myBash.IfStatement;
import org.xtext.example.mydsl.myBash.MyBashPackage;
import org.xtext.example.mydsl.myBash.Pipeline;
import org.xtext.example.mydsl.myBash.Redirection;
import org.xtext.example.mydsl.myBash.SimpleCommand;
import org.xtext.example.mydsl.myBash.SimpleList;
import org.xtext.example.mydsl.myBash.Word;
import org.xtext.example.mydsl.services.MyBashGrammarAccess;

@SuppressWarnings("all")
public class MyBashFormatter extends AbstractFormatter2 {
  @Inject
  @Extension
  private MyBashGrammarAccess _myBashGrammarAccess;
  
  protected void _format(final SimpleList simpleList, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.lowPriority();
      it.setNewLines(0, 1, 2);
    };
    document.<SimpleList>prepend(simpleList, _function);
  }
  
  protected void _format(final CompoundList compoundLists, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<CompoundList>surround(compoundLists, _function);
    EList<CommandUnit> _commands = compoundLists.getCommands();
    for (final CommandUnit command : _commands) {
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
        it.setNewLines(0, 1, 2);
      };
      CommandUnit _prepend = document.<CommandUnit>prepend(command, _function_1);
      document.<CommandUnit>format(_prepend);
    }
  }
  
  protected void _format(final Pipeline pipeline, @Extension final IFormattableDocument document) {
  }
  
  protected void _format(final SimpleCommand simpleCommand, @Extension final IFormattableDocument document) {
    EList<Assignment> _assignments = simpleCommand.getAssignments();
    final Consumer<Assignment> _function = (Assignment it) -> {
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it_1) -> {
        it_1.oneSpace();
      };
      document.<Assignment>prepend(it, _function_1);
    };
    _assignments.forEach(_function);
    Word _command = simpleCommand.getCommand();
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    document.<Word>prepend(_command, _function_1);
    EList<EObject> _parameters = simpleCommand.getParameters();
    final Consumer<EObject> _function_2 = (EObject it) -> {
      final Procedure1<IHiddenRegionFormatter> _function_3 = (IHiddenRegionFormatter it_1) -> {
        it_1.oneSpace();
      };
      document.<EObject>prepend(it, _function_3);
    };
    _parameters.forEach(_function_2);
    EList<Redirection> _r = simpleCommand.getR();
    final Consumer<Redirection> _function_3 = (Redirection it) -> {
      final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it_1) -> {
        it_1.oneSpace();
      };
      document.<Redirection>prepend(it, _function_4);
    };
    _r.forEach(_function_3);
    EList<Redirection> _r_1 = simpleCommand.getR();
    final Consumer<Redirection> _function_4 = (Redirection it) -> {
      document.<Redirection>format(it);
    };
    _r_1.forEach(_function_4);
  }
  
  protected void _format(final Redirection redirection, @Extension final IFormattableDocument document) {
    ISemanticRegionsFinder _regionFor = this.textRegionExtensions.regionFor(redirection);
    EAttribute _redirection_Op = MyBashPackage.eINSTANCE.getRedirection_Op();
    ISemanticRegion _feature = _regionFor.feature(_redirection_Op);
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.lowPriority();
      it.noSpace();
    };
    document.surround(_feature, _function);
  }
  
  protected void _format(final IfStatement ifStatement, @Extension final IFormattableDocument document) {
    ISemanticRegionsFinder _regionFor = this.textRegionExtensions.regionFor(ifStatement);
    ISemanticRegion _keyword = _regionFor.keyword("if");
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    document.prepend(_keyword, _function);
    CompoundList _condition = ifStatement.getCondition();
    CompoundList _format = document.<CompoundList>format(_condition);
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.oneSpace();
    };
    document.<CompoundList>surround(_format, _function_1);
    ISemanticRegionsFinder _regionFor_1 = this.textRegionExtensions.regionFor(ifStatement);
    ISemanticRegion _keyword_1 = _regionFor_1.keyword("then");
    final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
      it.highPriority();
      it.newLine();
    };
    document.append(_keyword_1, _function_2);
    CompoundList _then = ifStatement.getThen();
    document.<CompoundList>format(_then);
    EList<ElseIfBlock> _elseIfBlock = ifStatement.getElseIfBlock();
    final Consumer<ElseIfBlock> _function_3 = (ElseIfBlock it) -> {
      document.<ElseIfBlock>format(it);
    };
    _elseIfBlock.forEach(_function_3);
    CompoundList _else = ifStatement.getElse();
    document.<CompoundList>format(_else);
    ISemanticRegionsFinder _regionFor_2 = this.textRegionExtensions.regionFor(ifStatement);
    ISemanticRegion _keyword_2 = _regionFor_2.keyword("fi");
    final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it) -> {
      it.setNewLines(1, 1, 1);
    };
    document.prepend(_keyword_2, _function_4);
  }
  
  @Override
  public ITextReplacer createCommentReplacer(final IComment comment) {
    abstract class __MyBashFormatter_1 extends SinglelineCodeCommentReplacer {
      __MyBashFormatter_1(final IComment comment, final String prefix) {
        super(comment, prefix);
      }
      
      public abstract void enforceNewLine(final WhitespaceReplacer replacer);
    }
    
    EObject grammarElement = comment.getGrammarElement();
    if ((grammarElement instanceof AbstractRule)) {
      String ruleName = ((AbstractRule)grammarElement).getName();
      boolean _startsWith = ruleName.startsWith("SL");
      if (_startsWith) {
        return new __MyBashFormatter_1(comment, "#") {
          @Override
          public void configureWhitespace(final WhitespaceReplacer leading, final WhitespaceReplacer trailing) {
            this.enforceNewLine(trailing);
          }
          
          public void enforceNewLine(final WhitespaceReplacer replacer) {
            ITextSegment _region = replacer.getRegion();
            int _offset = _region.getOffset();
            boolean _lessEqualsThan = (_offset <= 0);
            if (_lessEqualsThan) {
              return;
            }
            IHiddenRegionFormatting _formatting = replacer.getFormatting();
            Integer min = _formatting.getNewLineMin();
            boolean _or = false;
            boolean _equals = Objects.equal(min, null);
            if (_equals) {
              _or = true;
            } else {
              _or = ((min).intValue() < 1);
            }
            if (_or) {
              IHiddenRegionFormatting _formatting_1 = replacer.getFormatting();
              _formatting_1.setNewLinesMin(Integer.valueOf(1));
            }
          }
        };
      }
    }
    GrammarElementTitleSwitch _grammarElementTitleSwitch = new GrammarElementTitleSwitch();
    GrammarElementTitleSwitch _showQualified = _grammarElementTitleSwitch.showQualified();
    GrammarElementTitleSwitch _showRule = _showQualified.showRule();
    String elementName = _showRule.doSwitch(grammarElement);
    String _simpleName = ITextReplacer.class.getSimpleName();
    String _plus = ("No " + _simpleName);
    String _plus_1 = (_plus + " configured for ");
    String _plus_2 = (_plus_1 + elementName);
    throw new IllegalStateException(_plus_2);
  }
  
  @Override
  public ITextReplacer createWhitespaceReplacer(final ITextSegment hiddens, final IHiddenRegionFormatting formatting) {
    return new MyBashWhitespaceReplacer(hiddens, formatting);
  }
  
  @Override
  public IFormattableDocument createFormattableRootDocument() {
    abstract class __MyBashFormatter_2 extends RootDocument {
      __MyBashFormatter_2(final AbstractFormatter2 formatter) {
        super(formatter);
      }
      
      public abstract IHiddenRegion getRealHiddenRegion(final IHiddenRegion hiddenRegion);
    }
    
    return new __MyBashFormatter_2(this) {
      @Override
      public Pair<IHiddenRegion, IHiddenRegion> set(final IHiddenRegion first, final IHiddenRegion second, final Procedure1<? super IHiddenRegionFormatter> init) {
        IHiddenRegion _realHiddenRegion = this.getRealHiddenRegion(first);
        IHiddenRegion _realHiddenRegion_1 = this.getRealHiddenRegion(second);
        return super.set(_realHiddenRegion, _realHiddenRegion_1, init);
      }
      
      @Override
      public IHiddenRegion set(final IHiddenRegion hiddenRegion, final Procedure1<? super IHiddenRegionFormatter> init) {
        IHiddenRegion _realHiddenRegion = this.getRealHiddenRegion(hiddenRegion);
        return super.set(_realHiddenRegion, init);
      }
      
      public IHiddenRegion getRealHiddenRegion(final IHiddenRegion hiddenRegion) {
        ISemanticRegion _nextSemanticRegion = hiddenRegion.getNextSemanticRegion();
        EObject _grammarElement = null;
        if (_nextSemanticRegion!=null) {
          _grammarElement=_nextSemanticRegion.getGrammarElement();
        }
        if ((_grammarElement instanceof RuleCall)) {
          ISemanticRegion _nextSemanticRegion_1 = hiddenRegion.getNextSemanticRegion();
          EObject _grammarElement_1 = null;
          if (_nextSemanticRegion_1!=null) {
            _grammarElement_1=_nextSemanticRegion_1.getGrammarElement();
          }
          RuleCall ruleCall = ((RuleCall) _grammarElement_1);
          AbstractRule _rule = null;
          if (ruleCall!=null) {
            _rule=ruleCall.getRule();
          }
          ParserRule _maybeNewLineRule = MyBashFormatter.this._myBashGrammarAccess.getMaybeNewLineRule();
          boolean _equals = Objects.equal(_rule, _maybeNewLineRule);
          if (_equals) {
            ISemanticRegion _nextSemanticRegion_2 = hiddenRegion.getNextSemanticRegion();
            IHiddenRegion region = _nextSemanticRegion_2.getNextHiddenRegion();
            return region;
          }
        }
        return hiddenRegion;
      }
    };
  }
  
  public void format(final Object ifStatement, final IFormattableDocument document) {
    if (ifStatement instanceof XtextResource) {
      _format((XtextResource)ifStatement, document);
      return;
    } else if (ifStatement instanceof IfStatement) {
      _format((IfStatement)ifStatement, document);
      return;
    } else if (ifStatement instanceof Pipeline) {
      _format((Pipeline)ifStatement, document);
      return;
    } else if (ifStatement instanceof SimpleCommand) {
      _format((SimpleCommand)ifStatement, document);
      return;
    } else if (ifStatement instanceof SimpleList) {
      _format((SimpleList)ifStatement, document);
      return;
    } else if (ifStatement instanceof CompoundList) {
      _format((CompoundList)ifStatement, document);
      return;
    } else if (ifStatement instanceof Redirection) {
      _format((Redirection)ifStatement, document);
      return;
    } else if (ifStatement instanceof EObject) {
      _format((EObject)ifStatement, document);
      return;
    } else if (ifStatement == null) {
      _format((Void)null, document);
      return;
    } else if (ifStatement != null) {
      _format(ifStatement, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(ifStatement, document).toString());
    }
  }
}
