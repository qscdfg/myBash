/*
 * generated by Xtext 2.9.1
 */
package org.xtext.example.mydsl.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.AbstractRule
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter
import org.eclipse.xtext.formatting2.IHiddenRegionFormatting
import org.eclipse.xtext.formatting2.ITextReplacer
import org.eclipse.xtext.formatting2.internal.RootDocument
import org.eclipse.xtext.formatting2.internal.SinglelineCodeCommentReplacer
import org.eclipse.xtext.formatting2.internal.WhitespaceReplacer
import org.eclipse.xtext.formatting2.regionaccess.IComment
import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegion
import org.eclipse.xtext.formatting2.regionaccess.ITextSegment
import org.eclipse.xtext.grammaranalysis.impl.GrammarElementTitleSwitch
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1
import org.xtext.example.mydsl.myBash.CompoundList
import org.xtext.example.mydsl.myBash.IfStatement
import org.xtext.example.mydsl.myBash.MyBashPackage
import org.xtext.example.mydsl.myBash.Pipeline
import org.xtext.example.mydsl.myBash.Redirection
import org.xtext.example.mydsl.myBash.SimpleCommand
import org.xtext.example.mydsl.myBash.SimpleList
import org.xtext.example.mydsl.services.MyBashGrammarAccess

class MyBashFormatter extends AbstractFormatter2 {

	@Inject extension MyBashGrammarAccess;

	def dispatch void format(SimpleList simpleList, extension IFormattableDocument document) {
		simpleList.prepend[lowPriority; setNewLines(0, 1, 2)]
	// var start = simpleList.regionFor.element(simpleListAccess.getAlternatives_1_1_0_0)?.nextHiddenRegion
	// if (start != null) {
	// //	var end = simpleList.nextHiddenRegion
	// set(start, end, [indent])
	// }
	// simpleList.piplines.forEach[format]
	}

	def dispatch void format(CompoundList compoundLists, extension IFormattableDocument document) {
		compoundLists.surround[indent]
		for (command : compoundLists.getCommands) {
			command.prepend[setNewLines(0, 1, 2)].format;
		}
	}

	def dispatch void format(Pipeline pipeline, extension IFormattableDocument document) {
		// for (Command command : pipeline.commands) {
		// command.prepend[setNewLines(0, 1, 2)].format;
		// }
	}

	def dispatch void format(SimpleCommand simpleCommand, extension IFormattableDocument document) {
		simpleCommand.assignments.forEach[prepend[oneSpace]]
		simpleCommand.command.prepend[oneSpace]
		simpleCommand.parameters.forEach[prepend[oneSpace]]
		simpleCommand.r.forEach[prepend[oneSpace]]
		simpleCommand.r.forEach[format]
	}

	def dispatch void format(Redirection redirection, extension IFormattableDocument document) {
		redirection.regionFor.feature(MyBashPackage.eINSTANCE.redirection_Op).surround[lowPriority; noSpace]
	}

	def dispatch void format(IfStatement ifStatement, extension IFormattableDocument document) {
		//
		ifStatement.regionFor.keyword('if').prepend[oneSpace]
		ifStatement.condition.format.surround[oneSpace]
		ifStatement.regionFor.keyword('then').append[highPriority; newLine]
		ifStatement.then.format
		ifStatement.elseIfBlock.forEach [
			format
		]
		ifStatement.^else.format
		ifStatement.regionFor.keyword('fi').prepend[setNewLines(1, 1, 1)]
	}

//##############################################################################################################################
	override createCommentReplacer(IComment comment) {
		var grammarElement = comment.getGrammarElement();
		if (grammarElement instanceof AbstractRule) {
			var ruleName = grammarElement.getName();
			if (ruleName.startsWith("SL")) {
				return new SinglelineCodeCommentReplacer(comment, "#") {
					override configureWhitespace(WhitespaceReplacer leading, WhitespaceReplacer trailing) {
						// super.configureWhitespace(leading, trailing)
						enforceNewLine(trailing);
					}

					def void enforceNewLine(WhitespaceReplacer replacer) {
						if (replacer.getRegion().getOffset() <= 0)
							return;
						var min = replacer.getFormatting().getNewLineMin();
						if (min == null || min < 1)
							replacer.getFormatting().setNewLinesMin(1);
					}
				};
			}
		}
		var elementName = new GrammarElementTitleSwitch().showQualified().showRule().doSwitch(grammarElement);
		throw new IllegalStateException("No " + ITextReplacer.getSimpleName() + " configured for " + elementName);
	}

	override ITextReplacer createWhitespaceReplacer(ITextSegment hiddens, IHiddenRegionFormatting formatting) {
		return new MyBashWhitespaceReplacer(hiddens, formatting);
	}

	override IFormattableDocument createFormattableRootDocument() {
		return new RootDocument(this) {

			override set(IHiddenRegion first, IHiddenRegion second, Procedure1<? super IHiddenRegionFormatter> init) {
				super.set(getRealHiddenRegion(first), getRealHiddenRegion(second), init)
			}

			override set(IHiddenRegion hiddenRegion, Procedure1<? super IHiddenRegionFormatter> init) {
				super.set(getRealHiddenRegion(hiddenRegion), init)
			}

			def IHiddenRegion getRealHiddenRegion(IHiddenRegion hiddenRegion) {
				if (hiddenRegion.nextSemanticRegion?.grammarElement instanceof RuleCall) {
					var ruleCall = hiddenRegion.nextSemanticRegion?.grammarElement as RuleCall
					if (ruleCall?.rule == maybeNewLineRule) {
						var region = hiddenRegion.nextSemanticRegion.nextHiddenRegion
						return region
					}
				}
				return hiddenRegion
			}
		};
	}

// TODO: implement for List1, Pipeline, RedirectionList, ShellCommand, CondCommand, SimpleCommand, Assignment, FunctionDefine, LocalDefine, CaseStatement, Pattern, IfStatement, ElseIfBlock, ForStatement, WhileStatement, Redirection, Array, WordNotS, DQuotaString, BraceString, ArithmeticExpansion, ParameterExpansion, CommandSubstitution, Arithmetics, Arithmetic, LogicOr, LogicAnd, PM, Compare
}
